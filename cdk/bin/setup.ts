// This script examines stack outputs and writes .env.local file
// eslint-disable-next-line import/named
import { CloudFormationClient, DescribeStacksCommand, DescribeStacksCommandOutput } from '@aws-sdk/client-cloudformation';
// eslint-disable-next-line import/named
import { GetParametersByPathCommand, GetParametersByPathCommandOutput, SSMClient } from '@aws-sdk/client-ssm';
import * as fs from 'fs';
import Config from '../lib/config';

const euWestCFClient = new CloudFormationClient({ region: 'eu-west-1' });
const euWestSSMClient = new SSMClient({ region: 'eu-west-1' });

type BackendStackOutputs = {
  AppSyncAPIURL: string;
  AppSyncAPIKey: string;
  LoadBalancerDnsName: string;
};

type FrontendStackOutputs = {
  CloudFrontDomainName: string;
};

async function readStackOutputsForRawStackName(stackName: string): Promise<Record<string, string>> {
  const output: DescribeStacksCommandOutput = await euWestCFClient.send(new DescribeStacksCommand({ StackName: stackName }));
  return (
    output.Stacks?.[0].Outputs?.reduce((params, param) => {
      // Include only non-null values. Exclude automatically generated outputs by CDK
      if (param.OutputKey && param.OutputValue && !param.OutputKey.startsWith('ExportsOutput')) {
        params[param.OutputKey] = param.OutputValue;
      }
      return params;
    }, {} as Record<string, string>) || {}
  );
}

async function readBackendStackOutputs(): Promise<BackendStackOutputs> {
  return (await readStackOutputsForRawStackName('DvkBackendStack-' + Config.getEnvironment())) as BackendStackOutputs;
}

async function readFrontendStackOutputs(): Promise<FrontendStackOutputs> {
  return (await readStackOutputsForRawStackName('SquatSiteStack-' + Config.getEnvironment())) as FrontendStackOutputs;
}

async function readParametersByPath(path: string): Promise<Record<string, string>> {
  const variables: Record<string, string> = {};
  let nextToken;
  do {
    const output: GetParametersByPathCommandOutput = await euWestSSMClient.send(
      new GetParametersByPathCommand({ Path: path, WithDecryption: true, NextToken: nextToken })
    );
    output.Parameters?.forEach((param) => {
      if (param.Name && param.Value) {
        variables[param.Name.replace(path, '')] = param.Value;
      }
    });
    nextToken = output.NextToken;
  } while (nextToken);
  return variables;
}

async function readParametersForEnv<T extends Record<string, string>>(environment: string): Promise<T> {
  const results: Record<string, string> = {
    ...(await readParametersByPath('/')), // Read global parameters from root
    ...(await readParametersByPath('/' + environment + '/')), // Then override with environment specific ones if provided
  };
  return results as T;
}

function writeEnvFile(fileName: string, variables: { [p: string]: string }) {
  let envFile = '# This file is automatically generated\n';
  for (const key in variables) {
    // eslint-disable-next-line no-prototype-builtins
    if (variables.hasOwnProperty(key) && variables[key]) {
      envFile += `${key}=${variables[key]}\n`;
    }
  }
  fs.writeFileSync(fileName, envFile);
}

async function main() {
  const backendStackOutputs = await readBackendStackOutputs();
  const frontendStackOutputs = await readFrontendStackOutputs();
  const envParameters = await readParametersForEnv(Config.getEnvironment());
  const restAPIUrl = Config.isPermanentEnvironment()
    ? 'https://' + envParameters.DMZProxyEndpoint
    : 'http://' + backendStackOutputs.LoadBalancerDnsName;
  writeEnvFile('../.env.local', {
    REACT_APP_API_URL: backendStackOutputs.AppSyncAPIURL,
    REACT_APP_API_KEY: backendStackOutputs.AppSyncAPIKey,
    REACT_APP_REST_API_URL: `${restAPIUrl}/api`,
    REACT_APP_FRONTEND_DOMAIN_NAME: frontendStackOutputs.CloudFrontDomainName,
  });
}

main().catch((e) => {
  console.log(e);
  process.exit(1);
});
